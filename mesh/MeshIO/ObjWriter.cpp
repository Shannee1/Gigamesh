#include "ObjWriter.h"
#include <fstream>
#include <iostream>
#include <locale>
#include <filesystem>

using namespace std;


ObjWriter::ObjWriter()
{

}


bool ObjWriter::writeFile(const std::string& rFilename, const std::vector<sVertexProperties>& rVertexProps, const std::vector<sFaceProperties>& rFaceProps, MeshSeedExt& rMeshSeed)
{
	fstream filestr;
	filestr.imbue(std::locale("C"));
	int timeStart; // for performance mesurement

	timeStart = clock();
	filestr.open( rFilename.c_str(), fstream::out );
	if( !filestr.is_open() ) {
		cerr << "[ObjWriter::" << __FUNCTION__ << "] ERROR: Could not open file: '" << rFilename << "'!" << endl;
		return false;
	} else {
		cout << "[ObjWriter::" << __FUNCTION__ << "] File open for writing: '" << rFilename << "'." << endl;
	}
	filestr << "#===============================================================================" << endl;
	filestr << "# File generated by the GigaMesh Software Framework" << endl;
	filestr << "#-------------------------------------------------------------------------------" << endl;
	filestr << "# WebSite: https://gigamesh.eu" << endl;
	filestr << "# EMail:   info@gigamesh.eu" << endl;
	filestr << "#-------------------------------------------------------------------------------" << endl;
	filestr << "# Contact: Hubert MARA <hubert.mara@iwr.uni-heidelberg.de>" << endl;
	filestr << "#          IWR - Heidelberg University, Germany" << endl;
	filestr << "#===============================================================================" << endl;
	filestr << "# GigaMesh compiled" << endl;
#ifdef COMP_USER
	filestr << "# .... by: " << COMP_USER << endl;
#else
	filestr << "# .... by: UNKNOWN" << endl;
#endif
#ifdef COMP_DATE
	filestr << "# .... at: " << COMP_DATE << endl;
#else
	filestr << "# .... at: UNKNOWN" << endl;
#endif
#ifdef COMP_EDIT
	filestr << "# ... for: " << COMP_EDIT << endl;
#else
	filestr << "# ... for: UNKNOWN" << endl;
#endif
#ifdef COMP_GITHEAD
	filestr << "# ... git-head: " << COMP_GITHEAD << endl;
#else
	filestr << "# ... git-head: UNKNOWN" << endl;
#endif
#ifdef VERSION_PACKAGE
	filestr << "# .... Version: " << VERSION_PACKAGE << endl;
#else
	filestr << "# .... Version: UNKNOWN" << endl;
#endif

	//! \todo: texture coordinate export and MTL export!

	filestr << "#===============================================================================" << endl;
	filestr << "# Meta-Data: " << endl;
	filestr << "#-------------------------------------------------------------------------------" << endl;
	for( uint64_t i=0; i<ModelMetaData::META_STRINGS_COUNT; i++ ) {
		ModelMetaData::eMetaStrings metaId = static_cast<ModelMetaData::eMetaStrings>( i );
		if( metaId == ModelMetaData::META_FILENAME ) { // Ignore the filename!
			continue;
		}
		string metaStr = MeshWriter::getModelMetaDataRef().getModelMetaString( metaId );
		if( metaStr.size() == 0 ) { // Ignore empty strings!
			continue;
		}
		string metaName;
		if( MeshWriter::getModelMetaDataRef().getModelMetaStringName( metaId, metaName ) ) {

			if(metaId == ModelMetaData::META_TEXTUREFILE)
			{
				continue;  //Export files from getTexturefilesRef instead.
			}

			filestr << "# " << metaName << " " << metaStr << endl;
		}
	}

	//save textures as comments => TODO: save MTL-file instead
	if(!MeshWriter::getModelMetaDataRef().getTexturefilesRef().empty())
	{
		for(const auto& texName : MeshWriter::getModelMetaDataRef().getTexturefilesRef())
		{
			auto prevPath = std::filesystem::current_path();
			std::filesystem::current_path(std::filesystem::absolute(rFilename).parent_path());
			filestr << "# TextureFile " << std::filesystem::relative(texName).string();
			std::filesystem::current_path(prevPath);
		}
	}

	filestr << "#===============================================================================" << endl;
	filestr << "# Vertices: " << endl;
	filestr << "#-------------------------------------------------------------------------------" << endl;

	for( const auto& vertexProp : rVertexProps) {
		filestr << "v ";
		filestr << vertexProp.mCoordX  << " ";
		filestr << vertexProp.mCoordY  << " ";
		filestr << vertexProp.mCoordZ  << " ";
		filestr << static_cast<unsigned short>( vertexProp.mColorRed ) << " ";
		filestr << static_cast<unsigned short>( vertexProp.mColorGrn ) << " ";
		filestr << static_cast<unsigned short>( vertexProp.mColorBle ) << " ";
		filestr << vertexProp.mFuncVal << " ";
		filestr << "\n";
	}

	if(mExportTextureCoordinates)
	{
		filestr << "#===============================================================================" << endl;
		filestr << "# TextureCoordinates: " << endl;
		filestr << "#-------------------------------------------------------------------------------" << endl;

		for(const auto& faceProp : rFaceProps)
		{
			for(int i = 0; i<3; ++i)
			{
				filestr << "vt ";
				filestr << faceProp.textureCoordinates[i * 2    ] << " ";
				filestr << faceProp.textureCoordinates[i * 2 + 1] << "\n";
			}
		}
	}

	filestr << "#-------------------------------------------------------------------------------" << endl;
	filestr << "# Faces: " << endl;
	filestr << "#-------------------------------------------------------------------------------" << endl;

	if( rFaceProps.size() == 0 ) {
		filestr << "# NONE present i.e. point cloud" << endl;
	}

	unsigned int texIndex = 1;
	for(const auto & rFaceProp : rFaceProps) {
		// OBJs start with ONE!
		filestr << "f ";

		if(mExportTextureCoordinates)
		{
			filestr << rFaceProp.mVertIdxA + 1 << "/" << texIndex++ << " ";
			filestr << rFaceProp.mVertIdxB + 1 << "/" << texIndex++ << " ";
			filestr << rFaceProp.mVertIdxC + 1 << "/" << texIndex++ << "\n";
		}

		else
		{
			filestr << rFaceProp.mVertIdxA+1 << " ";
			filestr << rFaceProp.mVertIdxB+1 << " ";
			filestr << rFaceProp.mVertIdxC+1 << "\n";
		}
	}

	filestr << "#-------------------------------------------------------------------------------" << endl;

	unsigned int lineCount = rMeshSeed.getPolyLineNr();
	if( lineCount > 0 ) {
		filestr << "# Lines: " << endl;
		filestr << "#-------------------------------------------------------------------------------" << endl;

		for( unsigned int i=0; i<lineCount; i++ ) {
			filestr << "l";
			for( unsigned int j=0; j<rMeshSeed.getPolyLineLength( i ); j++ ) {
				// OBJs start with ONE!
				filestr << " " << rMeshSeed.getPolyLineVertIdx( i, j )+1;
			}
			filestr << endl;
		}

		filestr << "#-------------------------------------------------------------------------------" << endl;
	}

	filestr.close();
	cout << "[ObjWriter::" << __FUNCTION__ << "] write ASCII OBJ:      " << static_cast<float>( clock() -timeStart ) / CLOCKS_PER_SEC << " seconds. " << endl;
}
