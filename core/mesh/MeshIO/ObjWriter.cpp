#include "ObjWriter.h"
#include <fstream>
#include <iostream>
#include <locale>
#include <filesystem>
#include <map>
#include <list>

#include <GigaMesh/logging/Logging.h>

using namespace std;

void writeMTL(const std::vector<std::filesystem::path>& textureFiles, const std::string& fileName)
{
	std::fstream filestr;
	filestr.imbue(std::locale("C"));

	filestr.open( fileName, fstream::out);
	if(!filestr.is_open())
	{
		LOG::error() << "[ObjWriter::" << __FUNCTION__ << "] ERROR: Could not open file for MTL: '" << fileName << "'!\n";
		return;
	}


	auto prevPath = std::filesystem::current_path();
	std::filesystem::current_path(std::filesystem::absolute(fileName).parent_path());

	unsigned short texId = 0;
	for(const auto& textureFile : textureFiles)
	{
		filestr << "newmtl Material_" << std::to_string(texId++) << '\n';
		filestr << "Kd 1.0 1.0 1.0\n";
		filestr << "d 1.0\n";
		filestr << "illum 1\n";
		filestr << "map_Kd " << std::filesystem::relative(textureFile).string() << "\n\n";
	}

	std::filesystem::current_path(prevPath);
	filestr.close();
}

bool ObjWriter::writeFile(const std::filesystem::path& rFilename, const std::vector<sVertexProperties>& rVertexProps, const std::vector<sFaceProperties>& rFaceProps, MeshSeedExt& rMeshSeed)
{
	fstream filestr;
	filestr.imbue(std::locale("C"));
	int timeStart; // for performance mesurement

	timeStart = clock();
	filestr.open( rFilename, fstream::out );
	if( !filestr.is_open() ) {
		LOG::error() << "[ObjWriter::" << __FUNCTION__ << "] ERROR: Could not open file: '" << rFilename << "'!" << '\n';
		return false;
	} else {
		LOG::debug() << "[ObjWriter::" << __FUNCTION__ << "] File open for writing: '" << rFilename << "'." << '\n';
	}
	filestr << "#===============================================================================" << '\n';
	filestr << "# File generated by the GigaMesh Software Framework" << '\n';
	filestr << "#-------------------------------------------------------------------------------" << '\n';
	filestr << "# WebSite: https://gigamesh.eu" << '\n';
	filestr << "# EMail:   info@gigamesh.eu" << '\n';
	filestr << "#-------------------------------------------------------------------------------" << '\n';
	filestr << "# Contact: Hubert MARA <hubert.mara@iwr.uni-heidelberg.de>" << '\n';
	filestr << "#          IWR - Heidelberg University, Germany" << '\n';
	filestr << "#===============================================================================" << '\n';
	filestr << "# GigaMesh compiled" << '\n';
#ifdef COMP_USER
	filestr << "# .... by: " << COMP_USER << '\n';
#else
	filestr << "# .... by: UNKNOWN" << '\n';
#endif
#ifdef COMP_DATE
	filestr << "# .... at: " << COMP_DATE << '\n';
#else
	filestr << "# .... at: UNKNOWN" << '\n';
#endif
#ifdef COMP_EDIT
	filestr << "# ... for: " << COMP_EDIT << '\n';
#else
	filestr << "# ... for: UNKNOWN" << '\n';
#endif
#ifdef COMP_GITHEAD
	filestr << "# ... git-head: " << COMP_GITHEAD << '\n';
#else
	filestr << "# ... git-head: UNKNOWN" << '\n';
#endif
#ifdef VERSION_PACKAGE
	filestr << "# .... Version: " << VERSION_PACKAGE << '\n';
#else
	filestr << "# .... Version: UNKNOWN" << '\n';
#endif

	//! \todo: texture coordinate export and MTL export!

	filestr << "#===============================================================================" << '\n';
	filestr << "# Meta-Data: " << '\n';
	filestr << "#-------------------------------------------------------------------------------" << '\n';
	for( uint64_t i=0; i<ModelMetaData::META_STRINGS_COUNT; i++ ) {
		ModelMetaData::eMetaStrings metaId = static_cast<ModelMetaData::eMetaStrings>( i );
		if( metaId == ModelMetaData::META_FILENAME ) { // Ignore the filename!
			continue;
		}
		string metaStr = MeshWriter::getModelMetaDataRef().getModelMetaString( metaId );
		if( metaStr.size() == 0 ) { // Ignore empty strings!
			continue;
		}
		string metaName;
		if( MeshWriter::getModelMetaDataRef().getModelMetaStringName( metaId, metaName ) ) {

			if(metaId == ModelMetaData::META_TEXTUREFILE)
			{
				continue;  //Export files from getTexturefilesRef instead.
			}

			filestr << "# " << metaName << " " << metaStr << '\n';
		}
	}

	//save textures as comments => TODO: save MTL-file instead
	if(!MeshWriter::getModelMetaDataRef().getTexturefilesRef().empty())
	{
		for(const auto& texName : MeshWriter::getModelMetaDataRef().getTexturefilesRef())
		{
			auto prevPath = std::filesystem::current_path();
			std::filesystem::current_path(std::filesystem::absolute(rFilename).parent_path());
			filestr << "# TextureFile " << std::filesystem::relative(texName).string() << "\n";
			std::filesystem::current_path(prevPath);
		}

		filestr << "mtllib " << rFilename.stem().string() << ".mtl\n";
	}


	filestr << "#===============================================================================" << '\n';
	filestr << "# Vertices: " << '\n';
	filestr << "#-------------------------------------------------------------------------------" << '\n';

	for( const auto& vertexProp : rVertexProps) {
		filestr << "v ";
		filestr << vertexProp.mCoordX  << " ";
		filestr << vertexProp.mCoordY  << " ";
		filestr << vertexProp.mCoordZ  << " ";
		filestr << static_cast<unsigned short>( vertexProp.mColorRed ) << " ";
		filestr << static_cast<unsigned short>( vertexProp.mColorGrn ) << " ";
		filestr << static_cast<unsigned short>( vertexProp.mColorBle ) << " ";
		filestr << vertexProp.mFuncVal << " ";
		filestr << "\n";
	}

	//!TODO: write texture coordinates as vec2 into set, to avoid duplicates
	if(mExportTextureCoordinates)
	{
		filestr << "#===============================================================================" << '\n';
		filestr << "# TextureCoordinates: " << '\n';
		filestr << "#-------------------------------------------------------------------------------" << '\n';

		for(const auto& faceProp : rFaceProps)
		{
			for(size_t i = 0; i<faceProp.textureCoordinates.size(); i+=2)
			{
				filestr << "vt ";
				filestr << faceProp.textureCoordinates[i * 2    ] << " ";
				filestr << faceProp.textureCoordinates[i * 2 + 1] << "\n";
			}
		}
	}

	filestr << "#-------------------------------------------------------------------------------" << '\n';
	filestr << "# Faces: " << '\n';
	filestr << "#-------------------------------------------------------------------------------" << '\n';

	if( rFaceProps.size() == 0 ) {
		filestr << "# NONE present i.e. point cloud" << '\n';
	}

	if(MeshWriter::getModelMetaDataRef().getTexturefilesRef().empty())
	{
		unsigned int texIndex = 1;
		for(const auto & rFaceProp : rFaceProps) {
			// OBJs start with ONE!
			filestr << "f";

			if(mExportTextureCoordinates)
			{
				for(auto vertIndex : rFaceProp.vertexIndices)
				{
					filestr << " " <<  vertIndex + 1 << "/" << texIndex++;
				}
			}
			else
			{
				for(auto vertIndex : rFaceProp.vertexIndices)
				{
					filestr << " " <<  vertIndex + 1;
				}
			}
			filestr << "\n";
		}
	}

	else
	{
		std::map<unsigned short, std::list<const sFaceProperties*>> facesPerTextureLists;

		for(const auto& rFaceProp : rFaceProps)
		{
			facesPerTextureLists[rFaceProp.textureId].push_back(&rFaceProp);
		}

		for(const auto& textureListPair : facesPerTextureLists)
		{
			filestr << "usemtl Material_" << std::to_string(static_cast<unsigned short>(textureListPair.first)) << '\n';

			unsigned int texIndex = 1;
			for(const auto & rFaceProp : textureListPair.second) {
				// OBJs start with ONE!
				filestr << "f ";

				if(mExportTextureCoordinates)
				{
					for(auto vertIndex : rFaceProp->vertexIndices)
					{
						filestr << " " <<  vertIndex + 1 << "/" << texIndex++;
					}
				}
				else
				{
					for(auto vertIndex : rFaceProp->vertexIndices)
					{
						filestr << " " <<  vertIndex + 1;
					}
				}
				filestr << "\n";
			}
		}
	}
	filestr << "#-------------------------------------------------------------------------------" << '\n';

	unsigned int lineCount = rMeshSeed.getPolyLineNr();
	if( lineCount > 0 ) {
		filestr << "# Lines: " << '\n';
		filestr << "#-------------------------------------------------------------------------------" << '\n';

		for( unsigned int i=0; i<lineCount; i++ ) {
			filestr << "l";
			for( unsigned int j=0; j<rMeshSeed.getPolyLineLength( i ); j++ ) {
				// OBJs start with ONE!
				filestr << " " << rMeshSeed.getPolyLineVertIdx( i, j )+1;
			}
			filestr << '\n';
		}

		filestr << "#-------------------------------------------------------------------------------" << '\n';
	}

	filestr.close();

	if(!MeshWriter::getModelMetaDataRef().getTexturefilesRef().empty())
	{
		std::string mtlFileName = std::filesystem::absolute(rFilename).replace_extension(".mtl").string();

		writeMTL(MeshWriter::getModelMetaDataRef().getTexturefilesRef(), mtlFileName);
	}

	LOG::debug() << "[ObjWriter::" << __FUNCTION__ << "] write ASCII OBJ:      " << static_cast<float>( clock() -timeStart ) / CLOCKS_PER_SEC << " seconds. " << '\n';

	return true;
}

